-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\detector\Accumulator.vhd
-- Created: 2022-09-01 15:45:31
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: Accumulator
-- Source Path: detector/detector/Accumulator
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.detector_pkg.ALL;

ENTITY Accumulator IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        energyIn                          :   IN    std_logic_vector(27 DOWNTO 0);  -- sfix28
        result                            :   OUT   std_logic_vector(31 DOWNTO 0)  -- int32
        );
END Accumulator;


ARCHITECTURE rtl OF Accumulator IS

  -- Signals
  SIGNAL energyIn_signed                  : signed(27 DOWNTO 0);  -- sfix28
  SIGNAL result_tmp                       : signed(31 DOWNTO 0);  -- int32
  SIGNAL delayOutputs                     : vector_of_signed28(0 TO 15);  -- sfix28 [16]
  SIGNAL energy                           : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL diffEnergy                       : signed(30 DOWNTO 0);  -- sfix31
  SIGNAL delayOutputs_next                : vector_of_signed28(0 TO 15);  -- sfix28 [16]
  SIGNAL energy_next                      : signed(31 DOWNTO 0);  -- sfix32
  SIGNAL diffEnergy_next                  : signed(30 DOWNTO 0);  -- sfix31

BEGIN
  energyIn_signed <= signed(energyIn);

  Accumulator_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '0' THEN
      delayOutputs <= (OTHERS => to_signed(16#0000000#, 28));
      energy <= to_signed(0, 32);
      diffEnergy <= to_signed(16#00000000#, 31);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayOutputs <= delayOutputs_next;
        energy <= energy_next;
        diffEnergy <= diffEnergy_next;
      END IF;
    END IF;
  END PROCESS Accumulator_1_process;

  Accumulator_1_output : PROCESS (delayOutputs, diffEnergy, energy, energyIn_signed)
    VARIABLE energyOut : signed(27 DOWNTO 0);
    VARIABLE add_cast : signed(30 DOWNTO 0);
  BEGIN
    delayOutputs_next <= delayOutputs;
    --    %% Registers
    --energyIn = fi(energyIn,0,numberOfBitsDelay,0,'RoundingMethod','floor', 'SumMode','FullPrecision','ProductMode','FullPrecision'); 
    --    %% Set outputs
    --    %% Update registers
    energyOut := delayOutputs(15);
    delayOutputs_next(1 TO 15) <= delayOutputs(0 TO 14);
    delayOutputs_next(0) <= energyIn_signed;
    --aa = fi(energy,1,numberOfBitsEnergy-2,0) + fi(energyIn,1,numberOfBitsEnergy-2,0) - fi(energyOut,1,numberOfBitsEnergy-2,0); % Full implementation
    --energy = aa;
    add_cast := energy(30 DOWNTO 0);
    energy_next <= resize(add_cast, 32) + resize(diffEnergy, 32);
    diffEnergy_next <= resize(energyIn_signed, 31) - resize(energyOut, 31);
    result_tmp <= energy;
  END PROCESS Accumulator_1_output;


  result <= std_logic_vector(result_tmp);

END rtl;

