-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\detector\xcorr.vhd
-- Created: 2022-09-01 15:45:31
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: xcorr
-- Source Path: detector/detector/xcorr
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.detector_pkg.ALL;

ENTITY xcorr IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        inputI                            :   IN    vector_of_std_logic_vector12(0 TO 7);  -- sfix12 [8]
        inputQ                            :   IN    vector_of_std_logic_vector12(0 TO 7);  -- sfix12 [8]
        resultI                           :   OUT   vector_of_std_logic_vector16(0 TO 7);  -- int16 [8]
        resultQ                           :   OUT   vector_of_std_logic_vector16(0 TO 7)  -- int16 [8]
        );
END xcorr;


ARCHITECTURE rtl OF xcorr IS

  -- Constants
  CONSTANT sequenceBinary                 : matrix_of_std_logic(0 TO 7, 0 TO 15) := 
    (( '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', '0', '0', '0', '1', '1' ),
     ( '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', '0', '0', '0', '1', '1' ),
     ( '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', '0', '0', '0', '1', '1' ),
     ( '1', '1', '1', '1', '0', '1', '1', '0', '1', '0', '1', '0', '0', '0', '1', '1' ),
     ( '1', '1', '0', '0', '0', '1', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0' ),
     ( '1', '1', '0', '0', '0', '1', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0' ),
     ( '1', '1', '0', '0', '0', '1', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0' ),
     ( '1', '1', '0', '0', '0', '1', '0', '1', '1', '0', '0', '1', '0', '0', '0', '0' ));  -- ufix1 [8x16]

  -- Signals
  SIGNAL inputI_signed                    : vector_of_signed12(0 TO 7);  -- sfix12 [8]
  SIGNAL inputQ_signed                    : vector_of_signed12(0 TO 7);  -- sfix12 [8]
  SIGNAL resultI_tmp                      : vector_of_signed16(0 TO 7);  -- int16 [8]
  SIGNAL resultQ_tmp                      : vector_of_signed16(0 TO 7);  -- int16 [8]
  SIGNAL delayIOutputs                    : matrix_of_signed16(0 TO 15, 0 TO 7);  -- sfix16 [16x8]
  SIGNAL delayQOutputs                    : matrix_of_signed16(0 TO 15, 0 TO 7);  -- sfix16 [16x8]
  SIGNAL delayIOutputs_next               : matrix_of_signed16(0 TO 15, 0 TO 7);  -- sfix16 [16x8]
  SIGNAL delayQOutputs_next               : matrix_of_signed16(0 TO 15, 0 TO 7);  -- sfix16 [16x8]

BEGIN
  outputgen3: FOR k IN 0 TO 7 GENERATE
    inputI_signed(k) <= signed(inputI(k));
  END GENERATE;

  outputgen2: FOR k IN 0 TO 7 GENERATE
    inputQ_signed(k) <= signed(inputQ(k));
  END GENERATE;

  xcorr_1_process : PROCESS (clk, reset)
    VARIABLE i_0 : INTEGER;
    VARIABLE i2_0 : INTEGER;
  BEGIN
    IF reset = '0' THEN

      FOR i_0 IN 0 TO 7 LOOP
        FOR i2_0 IN 0 TO 15 LOOP
          delayIOutputs(i2_0, i_0) <= to_signed(16#0000#, 16);
          delayQOutputs(i2_0, i_0) <= to_signed(16#0000#, 16);
        END LOOP;
      END LOOP;

    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN

        FOR i IN 0 TO 7 LOOP
          FOR i2 IN 0 TO 15 LOOP
            delayIOutputs(i2, i) <= delayIOutputs_next(i2, i);
            delayQOutputs(i2, i) <= delayQOutputs_next(i2, i);
          END LOOP;
        END LOOP;

      END IF;
    END IF;
  END PROCESS xcorr_1_process;

  xcorr_1_output : PROCESS (delayIOutputs, delayQOutputs, inputI_signed, inputQ_signed)
    VARIABLE subSequence : std_logic_vector(0 TO 15);
    VARIABLE sumsResults : vector_of_signed16(0 TO 14);
    VARIABLE inputVal : signed(11 DOWNTO 0);
    VARIABLE inputP : signed(11 DOWNTO 0);
    VARIABLE yfi : signed(11 DOWNTO 0);
    VARIABLE yfi_0 : signed(11 DOWNTO 0);
    VARIABLE delayIOutputs_temp : matrix_of_signed16(0 TO 15, 0 TO 7);
    VARIABLE delayQOutputs_temp : matrix_of_signed16(0 TO 15, 0 TO 7);
    VARIABLE subsequence_0 : std_logic_vector(0 TO 15);
    VARIABLE inputval_0 : signed(11 DOWNTO 0);
    VARIABLE inputp_0 : signed(11 DOWNTO 0);
    VARIABLE sumsresults_0 : vector_of_signed16(0 TO 14);
    VARIABLE t_4 : vector_of_signed13(0 TO 7);
    VARIABLE add_temp : vector_of_signed17(0 TO 14);
    VARIABLE add_temp_0 : vector_of_signed17(0 TO 14);
    VARIABLE t_5 : vector_of_signed13(0 TO 7);
    VARIABLE add_temp_1 : vector_of_signed17(0 TO 14);
    VARIABLE add_temp_2 : vector_of_signed17(0 TO 14);
  BEGIN
    inputVal := to_signed(16#000#, 12);
    inputP := to_signed(16#000#, 12);
    inputval_0 := to_signed(16#000#, 12);
    inputp_0 := to_signed(16#000#, 12);
    yfi := to_signed(16#000#, 12);
    yfi_0 := to_signed(16#000#, 12);

    FOR i IN 0 TO 7 LOOP
      FOR i2 IN 0 TO 15 LOOP
        delayIOutputs_temp(i2, i) := delayIOutputs(i2, i);
        delayQOutputs_temp(i2, i) := delayQOutputs(i2, i);
      END LOOP;
    END LOOP;

    --    %% Registers
    --    %% Set outputs
    --sum(delayIOutputs(end,:));
    --sum(delayQOutputs(end,:));
    --    %% Update registers

    FOR indexXcorr IN 0 TO 7 LOOP

      FOR t_0 IN 0 TO 15 LOOP
        subSequence(t_0) := sequenceBinary(indexXcorr, t_0);
      END LOOP;

      inputVal := inputI_signed(indexXcorr);
      t_4(indexXcorr) :=  - (resize(inputI_signed(indexXcorr), 13));
      IF (t_4(indexXcorr)(12) = '0') AND (t_4(indexXcorr)(11) /= '0') THEN 
        yfi := "011111111111";
      ELSIF (t_4(indexXcorr)(12) = '1') AND (t_4(indexXcorr)(11) /= '1') THEN 
        yfi := "100000000000";
      ELSE 
        yfi := t_4(indexXcorr)(11 DOWNTO 0);
      END IF;
      IF subSequence(0) = '1' THEN 
        inputP := inputVal;
      ELSE 
        inputP := yfi;
      END IF;

      FOR indSumResult IN 0 TO 14 LOOP
        IF subSequence(indSumResult + 1) = '1' THEN 
          add_temp_0(indSumResult) := resize(delayIOutputs_temp(indSumResult, indexXcorr), 17) + resize(inputVal, 17);
          IF (add_temp_0(indSumResult)(16) = '0') AND (add_temp_0(indSumResult)(15) /= '0') THEN 
            sumsResults(indSumResult) := X"7FFF";
          ELSIF (add_temp_0(indSumResult)(16) = '1') AND (add_temp_0(indSumResult)(15) /= '1') THEN 
            sumsResults(indSumResult) := X"8000";
          ELSE 
            sumsResults(indSumResult) := add_temp_0(indSumResult)(15 DOWNTO 0);
          END IF;
        ELSE 
          add_temp(indSumResult) := resize(delayIOutputs_temp(indSumResult, indexXcorr), 17) + resize(yfi, 17);
          IF (add_temp(indSumResult)(16) = '0') AND (add_temp(indSumResult)(15) /= '0') THEN 
            sumsResults(indSumResult) := X"7FFF";
          ELSIF (add_temp(indSumResult)(16) = '1') AND (add_temp(indSumResult)(15) /= '1') THEN 
            sumsResults(indSumResult) := X"8000";
          ELSE 
            sumsResults(indSumResult) := add_temp(indSumResult)(15 DOWNTO 0);
          END IF;
        END IF;
      END LOOP;

      delayIOutputs_temp(0, indexXcorr) := resize(inputP, 16);

      FOR t_2 IN 0 TO 14 LOOP
        delayIOutputs_temp(t_2 + 1, indexXcorr) := sumsResults(t_2);
      END LOOP;


      FOR t_1 IN 0 TO 15 LOOP
        subsequence_0(t_1) := sequenceBinary(indexXcorr, t_1);
      END LOOP;

      inputval_0 := inputQ_signed(indexXcorr);
      t_5(indexXcorr) :=  - (resize(inputQ_signed(indexXcorr), 13));
      IF (t_5(indexXcorr)(12) = '0') AND (t_5(indexXcorr)(11) /= '0') THEN 
        yfi_0 := "011111111111";
      ELSIF (t_5(indexXcorr)(12) = '1') AND (t_5(indexXcorr)(11) /= '1') THEN 
        yfi_0 := "100000000000";
      ELSE 
        yfi_0 := t_5(indexXcorr)(11 DOWNTO 0);
      END IF;
      IF subsequence_0(0) = '1' THEN 
        inputp_0 := inputval_0;
      ELSE 
        inputp_0 := yfi_0;
      END IF;

      FOR indsumresult_0 IN 0 TO 14 LOOP
        IF subsequence_0(indsumresult_0 + 1) = '1' THEN 
          add_temp_2(indsumresult_0) := resize(delayQOutputs_temp(indsumresult_0, indexXcorr), 17) + resize(inputval_0, 17);
          IF (add_temp_2(indsumresult_0)(16) = '0') AND (add_temp_2(indsumresult_0)(15) /= '0') THEN 
            sumsresults_0(indsumresult_0) := X"7FFF";
          ELSIF (add_temp_2(indsumresult_0)(16) = '1') AND (add_temp_2(indsumresult_0)(15) /= '1') THEN 
            sumsresults_0(indsumresult_0) := X"8000";
          ELSE 
            sumsresults_0(indsumresult_0) := add_temp_2(indsumresult_0)(15 DOWNTO 0);
          END IF;
        ELSE 
          add_temp_1(indsumresult_0) := resize(delayQOutputs_temp(indsumresult_0, indexXcorr), 17) + resize(yfi_0, 17);
          IF (add_temp_1(indsumresult_0)(16) = '0') AND (add_temp_1(indsumresult_0)(15) /= '0') THEN 
            sumsresults_0(indsumresult_0) := X"7FFF";
          ELSIF (add_temp_1(indsumresult_0)(16) = '1') AND (add_temp_1(indsumresult_0)(15) /= '1') THEN 
            sumsresults_0(indsumresult_0) := X"8000";
          ELSE 
            sumsresults_0(indsumresult_0) := add_temp_1(indsumresult_0)(15 DOWNTO 0);
          END IF;
        END IF;
      END LOOP;

      delayQOutputs_temp(0, indexXcorr) := resize(inputp_0, 16);

      FOR t_3 IN 0 TO 14 LOOP
        delayQOutputs_temp(t_3 + 1, indexXcorr) := sumsresults_0(t_3);
      END LOOP;

      resultI_tmp(indexXcorr) <= delayIOutputs(15, indexXcorr);
      resultQ_tmp(indexXcorr) <= delayQOutputs(15, indexXcorr);
    END LOOP;


    FOR i_0 IN 0 TO 7 LOOP
      FOR i2_0 IN 0 TO 15 LOOP
        delayIOutputs_next(i2_0, i_0) <= delayIOutputs_temp(i2_0, i_0);
        delayQOutputs_next(i2_0, i_0) <= delayQOutputs_temp(i2_0, i_0);
      END LOOP;
    END LOOP;

  END PROCESS xcorr_1_output;


  outputgen1: FOR k IN 0 TO 7 GENERATE
    resultI(k) <= std_logic_vector(resultI_tmp(k));
  END GENERATE;

  outputgen: FOR k IN 0 TO 7 GENERATE
    resultQ(k) <= std_logic_vector(resultQ_tmp(k));
  END GENERATE;

END rtl;

