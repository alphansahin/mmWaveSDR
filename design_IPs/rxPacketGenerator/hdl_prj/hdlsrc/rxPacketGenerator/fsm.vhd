-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\rxPacketGenerator\fsm.vhd
-- Created: 2022-11-23 23:55:15
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fsm
-- Source Path: rxPacketGenerator/rxPacketGenerator/fsm
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY fsm IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        mode                              :   IN    std_logic;  -- ufix1
        softTrigger                       :   IN    std_logic;  -- ufix1
        transferEnable                    :   IN    std_logic;  -- ufix1
        transferSize                      :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        resetNumberOfTransfersCounter     :   IN    std_logic;  -- ufix1
        fifoCounter                       :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        stopCounter                       :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        detectorTrigger                   :   IN    std_logic;  -- ufix1
        s_tdata_re                        :   IN    std_logic_vector(127 DOWNTO 0);  -- ufix128
        s_tvalid_re                       :   IN    std_logic;  -- ufix1
        m_tready_re                       :   IN    std_logic;  -- ufix1
        s_tdata_im                        :   IN    std_logic_vector(127 DOWNTO 0);  -- ufix128
        s_tvalid_im                       :   IN    std_logic;  -- ufix1
        m_tready_im                       :   IN    std_logic;  -- ufix1
        m_tdata_re                        :   OUT   std_logic_vector(127 DOWNTO 0);  -- ufix128
        m_tvalid_re                       :   OUT   std_logic;
        m_tlast_re                        :   OUT   std_logic;
        m_tdata_im                        :   OUT   std_logic_vector(127 DOWNTO 0);  -- ufix128
        m_tvalid_im                       :   OUT   std_logic;
        m_tlast_im                        :   OUT   std_logic;
        s_tready_re                       :   OUT   std_logic;
        s_tready_im                       :   OUT   std_logic;
        data_re                           :   OUT   std_logic_vector(127 DOWNTO 0);  -- ufix128
        data_im                           :   OUT   std_logic_vector(127 DOWNTO 0);  -- ufix128
        numberOfTransfers                 :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END fsm;


ARCHITECTURE rtl OF fsm IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL transferSize_unsigned            : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL fifoCounter_unsigned             : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL stopCounter_unsigned             : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL s_tdata_re_unsigned              : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL s_tdata_im_unsigned              : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL m_tdata_re_tmp                   : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL m_tdata_im_tmp                   : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL data_re_tmp                      : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL data_im_tmp                      : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL numberOfTransfers_tmp            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL counter_numberOfTransfers_reg    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL counter_reg                      : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL counterCompleted_reg             : std_logic;  -- ufix1
  SIGNAL state_reg                        : std_logic;  -- ufix1
  SIGNAL softTrigger_reg                  : std_logic;  -- ufix1
  SIGNAL isThereEnoughRoom_reg            : std_logic;
  SIGNAL counter_numberOfTransfers_reg_next : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL counter_reg_next                 : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL counterCompleted_reg_next        : std_logic;  -- ufix1
  SIGNAL state_reg_next                   : std_logic;  -- ufix1
  SIGNAL softTrigger_reg_next             : std_logic;  -- ufix1
  SIGNAL isThereEnoughRoom_reg_next       : std_logic;

BEGIN
  transferSize_unsigned <= unsigned(transferSize);

  fifoCounter_unsigned <= unsigned(fifoCounter);

  stopCounter_unsigned <= unsigned(stopCounter);

  s_tdata_re_unsigned <= unsigned(s_tdata_re);

  s_tdata_im_unsigned <= unsigned(s_tdata_im);

  fsm_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '0' THEN
      counter_numberOfTransfers_reg <= to_unsigned(16#00000000#, 32);
      counter_reg <= to_unsigned(16#0000#, 16);
      counterCompleted_reg <= '0';
      state_reg <= '0';
      softTrigger_reg <= '0';
      isThereEnoughRoom_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        counter_numberOfTransfers_reg <= counter_numberOfTransfers_reg_next;
        counter_reg <= counter_reg_next;
        counterCompleted_reg <= counterCompleted_reg_next;
        state_reg <= state_reg_next;
        softTrigger_reg <= softTrigger_reg_next;
        isThereEnoughRoom_reg <= isThereEnoughRoom_reg_next;
      END IF;
    END IF;
  END PROCESS fsm_1_process;

  fsm_1_output : PROCESS (counterCompleted_reg, counter_numberOfTransfers_reg, counter_reg,
       detectorTrigger, fifoCounter_unsigned, isThereEnoughRoom_reg,
       m_tready_im, m_tready_re, mode, resetNumberOfTransfersCounter,
       s_tdata_im_unsigned, s_tdata_re_unsigned, s_tvalid_im, s_tvalid_re,
       softTrigger, softTrigger_reg, state_reg, stopCounter_unsigned,
       transferEnable, transferSize_unsigned)
    VARIABLE trigger : std_logic;
    VARIABLE changeState : std_logic;
    VARIABLE counterCompleted_reg_temp : std_logic;
  BEGIN
    changeState := '0';
    counterCompleted_reg_temp := counterCompleted_reg;
    counter_numberOfTransfers_reg_next <= counter_numberOfTransfers_reg;
    counter_reg_next <= counter_reg;
    state_reg_next <= state_reg;
    --    %% Initialize Registers
    --    %% Set outputs (delayed)
    m_tvalid_re <= hdlcoder_to_stdlogic(((state_reg = '1') AND (s_tvalid_re = '1')) AND (s_tvalid_im = '1'));
    s_tready_re <= hdlcoder_to_stdlogic(((state_reg = '1') AND (m_tready_re = '1')) AND (m_tready_im = '1'));
    m_tvalid_im <= hdlcoder_to_stdlogic(((state_reg = '1') AND (s_tvalid_im = '1')) AND (s_tvalid_im = '1'));
    s_tready_im <= hdlcoder_to_stdlogic(((state_reg = '1') AND (m_tready_im = '1')) AND (m_tready_im = '1'));
    trigger := hdlcoder_to_stdlogic((softTrigger_reg = '0') AND (softTrigger = '1'));
    IF  NOT (mode = '0') THEN 
      trigger := trigger OR detectorTrigger;
    END IF;
    --    %% Update Registers
    CASE state_reg IS
      WHEN '0' =>
        -- wait
        changeState := ((trigger AND transferEnable) AND hdlcoder_to_stdlogic(transferSize_unsigned > to_unsigned(16#00000000#, 16))) AND isThereEnoughRoom_reg;
        IF changeState = '1' THEN 
          state_reg_next <= '1';
        END IF;
        counter_reg_next <= transferSize_unsigned;
        IF resetNumberOfTransfersCounter = '1' THEN 
          counter_numberOfTransfers_reg_next <= to_unsigned(16#00000000#, 32);
        END IF;
        counterCompleted_reg_temp := '0';
      WHEN '1' =>
        -- count
        IF (((s_tvalid_re = '1') AND (m_tready_re = '1')) AND (s_tvalid_im = '1')) AND (m_tready_im = '1') THEN 
          IF counter_reg = to_unsigned(16#00000001#, 16) THEN 
            state_reg_next <= '0';
            counterCompleted_reg_temp := '1';
            counter_numberOfTransfers_reg_next <= counter_numberOfTransfers_reg + 1;
          END IF;
          counter_reg_next <= counter_reg - 1;
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    softTrigger_reg_next <= softTrigger;
    IF fifoCounter_unsigned < stopCounter_unsigned THEN 
      isThereEnoughRoom_reg_next <= '1';
    ELSE 
      isThereEnoughRoom_reg_next <= '0';
    END IF;
    --    %% Set outputs (not delayed)
    m_tdata_re_tmp <= s_tdata_re_unsigned;
    IF counterCompleted_reg_temp = '1' THEN 
      m_tlast_re <= '1';
    ELSE 
      m_tlast_re <= '0';
    END IF;
    m_tdata_im_tmp <= s_tdata_im_unsigned;
    IF counterCompleted_reg_temp = '1' THEN 
      m_tlast_im <= '1';
    ELSE 
      m_tlast_im <= '0';
    END IF;
    data_re_tmp <= s_tdata_re_unsigned;
    data_im_tmp <= s_tdata_im_unsigned;
    numberOfTransfers_tmp <= counter_numberOfTransfers_reg;
    counterCompleted_reg_next <= counterCompleted_reg_temp;
  END PROCESS fsm_1_output;


  m_tdata_re <= std_logic_vector(m_tdata_re_tmp);

  m_tdata_im <= std_logic_vector(m_tdata_im_tmp);

  data_re <= std_logic_vector(data_re_tmp);

  data_im <= std_logic_vector(data_im_tmp);

  numberOfTransfers <= std_logic_vector(numberOfTransfers_tmp);

END rtl;

