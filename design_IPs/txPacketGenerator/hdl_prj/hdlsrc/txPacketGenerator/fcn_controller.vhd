-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\txPacketGenerator\fcn_controller.vhd
-- Created: 2022-08-30 11:59:58
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fcn_controller
-- Source Path: txPacketGenerator/txPacketGenerator/fcn_controller
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY fcn_controller IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        packetSize                        :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        transferReady                     :   IN    std_logic;  -- ufix1
        s_tdata_re                        :   IN    std_logic_vector(127 DOWNTO 0);  -- ufix128
        s_tvalid_re                       :   IN    std_logic;  -- ufix1
        m_tready_re                       :   IN    std_logic;  -- ufix1
        s_tdata_im                        :   IN    std_logic_vector(127 DOWNTO 0);  -- ufix128
        s_tvalid_im                       :   IN    std_logic;  -- ufix1
        m_tready_im                       :   IN    std_logic;  -- ufix1
        m_tdata_re                        :   OUT   std_logic_vector(127 DOWNTO 0);  -- ufix128
        m_tvalid_re                       :   OUT   std_logic;
        s_tready_re                       :   OUT   std_logic;
        m_tdata_im                        :   OUT   std_logic_vector(127 DOWNTO 0);  -- ufix128
        m_tvalid_im                       :   OUT   std_logic;
        s_tready_im                       :   OUT   std_logic
        );
END fcn_controller;


ARCHITECTURE rtl OF fcn_controller IS

  -- Functions
  -- HDLCODER_TO_STDLOGIC 
  FUNCTION hdlcoder_to_stdlogic(arg: boolean) RETURN std_logic IS
  BEGIN
    IF arg THEN
      RETURN '1';
    ELSE
      RETURN '0';
    END IF;
  END FUNCTION;


  -- Signals
  SIGNAL packetSize_unsigned              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL s_tdata_re_unsigned              : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL s_tdata_im_unsigned              : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL m_tdata_re_tmp                   : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL m_tdata_im_tmp                   : unsigned(127 DOWNTO 0);  -- ufix128
  SIGNAL counter_reg_re                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL counter_reg_im                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL state_reg_re                     : std_logic;  -- ufix1
  SIGNAL state_reg_im                     : std_logic;  -- ufix1
  SIGNAL transferReady_reg                : std_logic;  -- ufix1
  SIGNAL counter_reg_re_next              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL counter_reg_im_next              : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL state_reg_re_next                : std_logic;  -- ufix1
  SIGNAL state_reg_im_next                : std_logic;  -- ufix1
  SIGNAL transferReady_reg_next           : std_logic;  -- ufix1

BEGIN
  packetSize_unsigned <= unsigned(packetSize);

  s_tdata_re_unsigned <= unsigned(s_tdata_re);

  s_tdata_im_unsigned <= unsigned(s_tdata_im);

  fcn_controller_1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '0' THEN
      counter_reg_re <= to_unsigned(16#0000#, 16);
      counter_reg_im <= to_unsigned(16#0000#, 16);
      state_reg_re <= '0';
      state_reg_im <= '0';
      transferReady_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        counter_reg_re <= counter_reg_re_next;
        counter_reg_im <= counter_reg_im_next;
        state_reg_re <= state_reg_re_next;
        state_reg_im <= state_reg_im_next;
        transferReady_reg <= transferReady_reg_next;
      END IF;
    END IF;
  END PROCESS fcn_controller_1_process;

  fcn_controller_1_output : PROCESS (counter_reg_im, counter_reg_re, m_tready_im, m_tready_re, packetSize_unsigned,
       s_tdata_im_unsigned, s_tdata_re_unsigned, s_tvalid_im, s_tvalid_re,
       state_reg_im, state_reg_re, transferReady, transferReady_reg)
    VARIABLE transferReady_risingEdge : std_logic;
    VARIABLE sub_cast : signed(16 DOWNTO 0);
    VARIABLE sub_temp : signed(16 DOWNTO 0);
    VARIABLE sub_cast_0 : signed(16 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(16 DOWNTO 0);
  BEGIN
    sub_temp := to_signed(16#00000#, 17);
    sub_temp_0 := to_signed(16#00000#, 17);
    sub_cast := to_signed(16#00000#, 17);
    sub_cast_0 := to_signed(16#00000#, 17);
    counter_reg_re_next <= counter_reg_re;
    counter_reg_im_next <= counter_reg_im;
    state_reg_re_next <= state_reg_re;
    state_reg_im_next <= state_reg_im;
    --    %% Initialize Registers
    --    %% Set outputs
    m_tvalid_re <= hdlcoder_to_stdlogic((state_reg_re = '1') AND (s_tvalid_re = '1'));
    s_tready_re <= hdlcoder_to_stdlogic((state_reg_re = '1') AND (m_tready_re = '1'));
    IF (state_reg_re = '1') AND (s_tvalid_re = '1') THEN 
      m_tdata_re_tmp <= s_tdata_re_unsigned;
    ELSE 
      m_tdata_re_tmp <= to_unsigned(0, 128);
    END IF;
    m_tvalid_im <= hdlcoder_to_stdlogic((state_reg_im = '1') AND (s_tvalid_im = '1'));
    s_tready_im <= hdlcoder_to_stdlogic((state_reg_im = '1') AND (m_tready_im = '1'));
    IF (state_reg_im = '1') AND (s_tvalid_im = '1') THEN 
      m_tdata_im_tmp <= s_tdata_im_unsigned;
    ELSE 
      m_tdata_im_tmp <= to_unsigned(0, 128);
    END IF;
    transferReady_risingEdge := hdlcoder_to_stdlogic((transferReady_reg = '0') AND (transferReady = '1'));
    --    %% Update Registers
    CASE state_reg_re IS
      WHEN '0' =>
        IF (transferReady_risingEdge AND hdlcoder_to_stdlogic(packetSize_unsigned > to_unsigned(16#00000000#, 16))) = '1' THEN 
          state_reg_re_next <= '1';
        END IF;
        counter_reg_re_next <= packetSize_unsigned;
      WHEN '1' =>
        IF (s_tvalid_re = '1') AND (m_tready_re = '1') THEN 
          IF counter_reg_re = to_unsigned(16#00000001#, 16) THEN 
            state_reg_re_next <= '0';
          END IF;
          sub_cast := signed(resize(counter_reg_re, 17));
          sub_temp := sub_cast - to_signed(16#00001#, 17);
          IF sub_temp(16) = '1' THEN 
            counter_reg_re_next <= X"0000";
          ELSE 
            counter_reg_re_next <= unsigned(sub_temp(15 DOWNTO 0));
          END IF;
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    CASE state_reg_im IS
      WHEN '0' =>
        IF (transferReady_risingEdge AND hdlcoder_to_stdlogic(packetSize_unsigned > to_unsigned(16#00000000#, 16))) = '1' THEN 
          state_reg_im_next <= '1';
        END IF;
        counter_reg_im_next <= packetSize_unsigned;
      WHEN '1' =>
        IF (s_tvalid_im = '1') AND (m_tready_im = '1') THEN 
          IF counter_reg_im = to_unsigned(16#00000001#, 16) THEN 
            state_reg_im_next <= '0';
          END IF;
          sub_cast_0 := signed(resize(counter_reg_im, 17));
          sub_temp_0 := sub_cast_0 - to_signed(16#00001#, 17);
          IF sub_temp_0(16) = '1' THEN 
            counter_reg_im_next <= X"0000";
          ELSE 
            counter_reg_im_next <= unsigned(sub_temp_0(15 DOWNTO 0));
          END IF;
        END IF;
      WHEN OTHERS => 
        NULL;
    END CASE;
    transferReady_reg_next <= transferReady;
  END PROCESS fcn_controller_1_output;


  m_tdata_re <= std_logic_vector(m_tdata_re_tmp);

  m_tdata_im <= std_logic_vector(m_tdata_im_tmp);

END rtl;

