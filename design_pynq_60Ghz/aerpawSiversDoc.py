# -*- coding: utf-8 -*-

chip_id_help = 'Chip Identification / Chip Identifcation Shadow\n(Big-endian, i.e MSB first).\nThis register doubles as Read-only (RO) Chip Idenfication and\nRead/Write (RW) Chip Identification Shadow register.\n\
Chip Identification Shadow is always written when this register\nis written.\n'

chip_id_sw_en_help = 'Configure access of Chip Idenification / Chip Identification Shadow register\nchip_id_sw_en = 0:\n\t\
Read: Chip Identification, Write: Chip Identification Shadow\nchip_id_sw_en = 1:\n\tRead/Write: Chip Identification Shadow'

fast_clk_ctrl_help = 'Fast clock control.\n Controls if the internal digital system clock\nis generated by an external clock on GPIO DIG_CLK\nor from an internal PLL synchronised to a reference\nclock on REF_P/REF_N-pins.\n\
The internal digital clock can also be fed out on GPIO DIG_CLK.\nBits\n0\tExternal source select\n1\tGPIO DIG_CLK output enable for fast clock\n4\tfast clock frequency select. (0 = 4xRef clock frequency, 1 = 5xRef clock frequency)\n\
5\tRef clock select (1: 45 MHz, 0: 40 MHz)'

gpio_tx_rx_sw_ctrl_help = 'GPIO TX_RX_SW control\nBits\n0\tTX_RX_SW output value\n1\tTX_RX_SW output enable (1=enable, 0=disable)\n4\tTX_RX_SW input value (Read-only)'
gpio_agc_rst_ctrl_help = 'GPIO AGC_RST control\nBits\n0\tAGC_RST output value\n1\tAGC_RST output enable (1=enable, 0=disable)\n4\tAGC_RST input value (Read-only)'
gpio_agc_start_ctrl_help = 'GPIO AGC_START control\nBits\n0\tAGC_START output value\n1\tAGC_START output enable (1=enable, 0=disable)\n4\tAGC_START input value (Read-only)'
gpio_agc_gain_in_ctrl_help = 'GPIO AGC_GAIN_x input/output value (x=3, 2, 1 or 0)\nBits\n3:0\tAGC_GAIN_x output value (x corresponds to bit position)\n7:4\tAGC_GAIN_x input value (Read-only)'
gpio_agc_gain_out_ctrl_help = 'GPIO AGC_GAIN_x output control\nBits\n3:0\tAGC_GAIN_x output enable (1=enable, 0=disable, x corresponds to bit position)\n7:4\tAGC_GAIN_x source select (0=AGC state machine, 1=this register)'
bist_amux_ctrl_help = 'BIST Analog Mux Control\nControls which internal analog source is connected to the AMUX-pin and to the internal ADC.\nBits\n3:0\tAnalog Mux select\n6\tDC Sense calibration (1=short DC sense diff input)\n7\tAnalog mux enable\
\nAnalog mux select\n0\tBG PLL\n1\tBG TX\n2\tBG RX\n3\tTemperature\n4\tBB_RX\n5\tPLL/VCO\n6\tVCC PLL\n7\tTX Power Detector (Peak)\n8\tADC reference\n9\tDC Sense I-channel\n10\tDC Sense Q-channel\n11\tDC Sense common mode\n12\tOTP control\n\
13\tTX Power detector (Envelope)\n14\tVCC PA * 3/4\n15\tVCC TX * 3/4'

bist_ot_ctrl_help = 'BIST Overtemp protection (OTP) control\nControls which OTP source to connect to AMUX-pin and ADC.\nEnables/Disables OTP function and OTP Alarm function.\nThe OTP function controls which parts of the chip should be turned off,\
 if the temperature becomes too high.\nNormally it is sufficient that the temperature drops below the treshold, to resume the turned off parts on again.\nThe OTP Alarm function enables the OTP function to keep these parts off until the OTP Alarm \
bit has been cleared instead.\nBits\n1:0\tOTP control\n4\tOTP enable (0=disable)\n5\tOTP Alarm enable (0=disable)\n\nOTP control\n00\tTemp Threshold\n01\tVDD 1.8 V \n10\tVDD 1.2 V\n11\tVCC RX * 3/4'

bist_ot_temp_help = 'BIST OTP Temperature Threshold\nSets threshold level for comparator indicating whether temperature is ok or not.\nOTP temperature OK bit shows this indication. OTP Alarm bit shows if any temperature not OK indication \
has occurred\nsince last time the OTP Alarm was cleared.\nBits\n4:0\tOTP threshold value\n6\tOTP Alarm (Read-only, Cleared when written with 1)\n7\tOTP temperature OK (Read-only)\n\nBits 7:6 interpretation\n00\tCurrently temperature is \
too high, but not earlier.\n01\tCurrently temperature is too high and it was earlier as well.\n10\tCurrently temperature is OK and it was earlier as well.\n11\tCurrently temperature is OK, but earlier it has been too high.\n'

bist_ot_rx_off_mask_help = 'BIST OTP RX off mask\n\t0 = Turn off corresponding function in RX\n\t1 = Allow corresponding bit in trx_rx_off to control on/off of function\nBits\n20\tEnable RX Q Baseband Output buffer\n19\tEnable RX Q Baseband \
Input Buffer, VGA1-3\n18\tEnable RX I Baseband Output buffer\n17\tEnable RX I Baseband Input Buffer, VGA1-3\n16\tEnable RX mixer- and LO-buffer, VGA and LNA\n15:0\tMask of RX RF port 15-0 Enables'

bist_ot_tx_off_mask_help = 'BIST OTP TX off mask\n\t0 = Turn off corresponding function in RX\n\t1 = Allow corresponding bit in trx_tx_off to control on/off of function\nBits\n20\tEnable TX PA bias loop\n19\tEnable TX phase shifter \
VGAs\n18\tEnable TX Q Baseband\n17\tEnable TX I Baseband\n16\tEnable TX mixer- and LO-buffer, VGA and PA\n15:0\tMask of  TX RF port 15-0 Enables'

spare_help = 'Spare registers\nBits\n31:0\tUnused'
bias_ctrl_help = 'LDO/Bias control\n(1=enable)\nBits\n0\tBG1V1 for PLL current mirrot Enable\n1\tLDO VCO Enable\n2\tLDO for CP/PLL current mirror Enable\n3\tLDO CP Enable\n4\tLDO PLL current mirror Enable\n5\tBias RF RX Enable\n6\tBias \
RF TX Enable'

bias_vco_x3_help = 'Bias for VCO X3 out buffer\nBits\n1:0\tX3 out bias\nX3 out bias\n00\t5.9 mA\n01\t7.2 mA\n10\t8.4 mA\n11\t9.7 mA'
bias_pll_help = 'Bias for PLL\nBits\n2:0\tIbias ctrl\n5:4\tIbias adjust\nIbias ctrl\n000\tDisable all\n001\tEnable Ref int\n010\tEnable Ref int, PFD\n011\tEnable Ref int, PFD, CHP\n100\tEnable Ref int, PFD, CHP, STM\n101\tEnable Ref int, \
PFD, CHP, STM, Div2\n110\tEnable Ref int, PFD, CHP, STM, Div2, DivN\n111\tEnable Ref int, PFD, CHP, STM, Div2, DivN, LD\nIbias adjust\n00\t80% of nominal bias\n01\tnominal bias\n10\t110% of nominal bias\n11\t136% of nominal bias'

bias_lo_help = 'Bias for LO X3\n00\t60% of nominal bias\n01\t80% of nominal bias\n10\tnominal bias\n11\t120% of nominal bias\nBits\n1:0\tLO X3 bias  21.2/2.2 mA (nom/off)\n3:2\tLO X3 TX buffer bias 10.6/1.1 mA (nom/off)\n5:4\tLO X3 RX \
buffer bias 10.6/1.1 mA (nom/off)'

bias_tx_help = 'Bias for TX-chain\n00\t60% of nominal bias\n01\t80% of nominal bias\n10\tnominal bias\n11\t120% of nominal bias\nBits\n1:0\tTX BB bias\n3:2\tTX VPA bias 16 x13.8/2.3 mA (nom/off)\n5:4\tTX VGA bias 16x21.7/0 mA \
(nom/off)\n7:6\tTX PA bias 16x28.4/4.5 mA (nom/off)\n9:8\tTX LO buffer mixer bias 30.3 mA (nom = bits 13:12)\n11:10\tTX IF buffer DC-level (nom = bits 13:12)\n13:12\tTX IF buffer bias ?10? mA (nom)\n15:14\tTX IF buffer bias fix'

bias_rx_help = 'Bias for RX-chain\n00\t60% of nominal bias\n01\t80% of nominal bias\n10\tnominal bias\n11\t120% of nominal bias\nBits\n1:0\tRX BB bias\n3:2\tRX VPA bias 16x11.6/2.26mA (nom/off)\n5:4\tRX VGA bias 16x19/0 mA \
(nom/off)\n7:6\tRX LNA bias 16x8.0/1.3 mA (nom/off)\n9:8\tRX mixer bias 10.7/4.1 mA (nom/off)\n11:10\tRX mixer LO bias 10.5/3 mA (nom/off)'

pll_en_help = 'PLL enable\nBits\n0\tDIVN enable\n1\tDIVBY2 Enable\n2\tBacklash (leak) Enable\n3\tLD enable\n4\tCHP Enable\n5\tPFD Enable\n6\tLow noise bias CHP Enable'
pll_divn_help = 'DIVN setting\nBits\n2:0\tS-count\n7:3\tP-count'
pll_pfd_help = 'PFD settings\nBits\n0\tPFD Test Enable\n1\tPFD Force up\n2\tPFD Force down'
pll_chp_help = 'CHP settings\nBits\n1:0\tCHP control\n6:4\tCHP leak\nCHP control\n00\tCHP current 400 uA\n01\tCHP current 600 uA\n10\tCHP current 800 uA\n11\tCHP current 1 mA\nCHP leak\n000\tLeak current 0 uA\n001\tLeak current \
10 uA\n010\tLeak current 20 uA\n011\tLeak current 30 uA\n100\tLeak current 40 uA\n101\tLeak current 50 uA\n110\tLeak current 60 uA\n111\tLeak current 70 uA'

pll_ld_mux_ctrl_help = 'Lock detect control\nBits 2:0 value (Mux Control)\n0\tFiltered lock detect\n1\tXOR output\n2\tPLL reference (/2)\n3\tVCO divider (/2)\n4\tUnfiltered lock detect\n5\tPLL test mux bit 0\n6\tPLL test mux bit \
1\n7\tUnused\nBits 5:4 value (Lock detect window)\n0:\t2 ns\n1:\t4 ns\n2:\t6 ns\n3:\t8 ns'

pll_test_mux_in_help = 'PLL test mux\nBits\n0\tValue for PLL test mux bit 0\n1\tValue for PLL test mux bit 1'
pll_ref_in_lvds_en_help = 'XO reference LVDS IO enable\nBits\n0\t1 = LVDS input, 0 = CMOS level input'
tx_ctrl_help = 'TX control\nBits\n0\tBB I-channel Invert\n1\tBB Q-channel Invert\n2\tBB IQ Swap\n3\tBB Ibias Set\n4\tBB IQ Input common mode (0: 1.00 V, 1: 0.25 V)\n5\tTX Envelope detector enable\n6\tTX -> RX loop enable'
tx_bb_q_dco_help = 'TX BB Q-channel DC offset\n\nBits 6:0 value (Offset)\n\n0x7F:\tMax positive offset value\n0x40:\tNo offset compensation\n0x00:\tMax negative offset value'
tx_bb_i_dco_help = 'TX BB I-channel DC offset\n\nBits 6:0 value (Offset)\n\n0x7F:\tMax positive offset value\n0x40:\tNo offset compensation\n0x00:\tMax negative offset value'
tx_bb_phase_help = 'TX BB phase\n\nBits 4:0 value (Phase)\n\n0x1F:\t+15°\n0x00:\t0°'
tx_bb_gain_help = 'TX BB gain\n\ntx_ctrl bit 3 (BB Ibias set) = 0\n0x00  = 0 dB\n0x01  = 6 dB\n0x02  = 6 dB\n0x03  = 9.5 dB\n\ntx_ctrl bit 3 (BB Ibias set) = 1\n0x00  = 0 dB\n0x01  = 3.5 dB\n0x02  = 3.5 dB\n0x03  = 6 dB'
tx_bb_iq_gain_help = 'TX BB I- and Q-channel gain\nBits\n3:0\tI-channel gain -> Range: 0 - 6 dB / 0x0 - 0xF\n7:4\tQ-channel gain -> Range: 0 - 6 dB / 0x0 - 0xF'
tx_bfrf_gain_help = 'TX BF VGA and RF VGA gain settings (Max gain 15dB typical)\n\nBits 3:0 value(RF Gain)\n0x0 = max gain – 15 dB\n ...\n0xF = max gain\n\nBits 7:4 value (BF gain)\n0x0 = max gain – 15 dB\n...\n0xF = max gain'
tx_bf_pdet_mux_help = 'TX BF Power Detector mux control\nBits\n3:0\tPower detector analog multiplexer\n5:4\tALC analog multiplexer\n7\tPower detector Enable\n\nALC analog multiplexer\n0x0:\tPower detector\n0x1:\tALC detector Hi \
threshold\n0x2:\tALC detector Lo threshold\n0x3:\tdig tune\n\nPower detector analog multiplexer\n0x0:\tTX0\n0x1:\tTX1\n...\n0xF:\tTX15'

tx_alc_ctrl_help = 'TX ALC control\nBits\n0\tEnable ALC function\n1\tStart ALC (Toggle bit)\n4\tALC temperature compensation enable\n5\tAdjust TX level during TX active\n6\tAdjust TX level during TX inactive\n7\tAdjust RF gain before BF gain'
tx_alc_loop_cnt_help = 'TX ALC loop count (7:0)\nSets number of times ALC is allowed to adjust gain'
tx_alc_start_delay_help = 'TX ALC start delay (15:0)\n\nSets delay from ALC trigger (run_once or TX becoming active)\nuntil TX ALC detetctors are observed.'
tx_alc_meas_delay_help = 'TX ALC measurement delay (7:0)\n\nSets delay from ALC gain change until TX ALC detetctors are observed again.'
tx_alc_bfrf_gain_max_help = 'TX BF VGA and RF VGA max gain settings for ALC function\n\nBits 3:0 value(RF gain)\n0x0 = max. gain - 15dB\n . . .\n0xf = max. gain\n\nBits 7:4 value(BF gain)\n0x0 = max. gain - 15dB\n . . .\n0xf = max. gain'
tx_alc_bfrf_gain_min_help = 'TX BF VGA and RF VGA min gain settings for ALC function\n\nBits 3:0 value(RF Gain)\n0x0 = max gain – 15 dB\n...\n0xF = max gain\n\nBits 7:4 value (BF gain)\n0x0 = max gain – 15 dB\n...\n0xF = max gain'
tx_alc_step_max_help = 'TX BF VGA and RF VGA gain step max for ALC function\n\nBits 1:0:\tRF gain step max\nBits 5:4:\tBF gain step max'
tx_alc_pdet_lo_th_help = 'TX ALC power detector Lo Treshold (7:0)'
tx_alc_pdet_hi_offs_th_help = 'TX ALC power detector Hi Threshold offset from Lo Threshold (4:0)'
tx_alc_bfrf_gain_help = 'TX BF VGA and RF VGA gain set by ALC function (Read-only)'
tx_alc_pdet_help = 'TX ALC Power detector threshold flags (Read-only)\n\nBits:\n0:\tALC Low indication\n1:\tALC High indication'
adc_ctrl_help = 'ADC Control\nBits\n0:\tEnable analogue part of ADC (Override automatic)\n1:\tClock edge (1=Rising, 0= Falling)\n2:\tContinuous\n4:\tStart (Toggle)\n5:\tReset (Toggle)\n7:\tReady (Read-only)'
adc_clk_div_help = 'ADC clock division factor\nADC sample clock = fast_clk / 38*(adc_clk_div+1)\nADC state machine clock = fast_clk / (adc_clk_div+1)\nBits\n7:0\tADC clock division factor'
adc_sample_cycle_help = 'ADC sample cycle\nValid values : 0-37\nBits\n5:0\tADC sample cycle'
adc_num_samples_help = 'ADC Log2 of number of samples\nValid values : 0-10\nNumber of samples = 2^adc_num_samples\nBits\n3:0\tLog2 of Number of samples' 
adc_sample_help = 'ADC sample\nBits\n11:0\tADC sample value'
adc_mean_help = 'ADC mean of Num of samples\nBits\n11:0\tADC sample value'
adc_max_help = 'ADC max among Num of samples\nBits\n11:0\tADC sample value'
adc_min_help = 'ADC min among Num of samples\nBits\n11:0\tADC sample value'
adc_diff_help = 'ADC sample diff (difference between current value and previous)\nBits\n12:0\tADC sample value'
vco_en_help = 'VCO enable\nBits\n0\tExternal LO buffer in Enable\n1\tExternal LO buffer out Enable\n2\tPLL divider buffer out Enable\n3\tX3 buffer out Enable\n4\tVCO Enable\n5\tComparator Enable\n6\tVCO Tune SM select (0=FD, 1=Vtune)'
vco_dig_tune_help = 'VCO Digital frequency tune override value\nBits 6:0 value\n0x00\tMin frequency\n0x7F\tMax frequency'
vco_ibias_help = 'VCO Amplitude setting override value\n\nNote! Values above 0x1F not recommended, use with care\n\n Bits 5:0 value\n0x00\tOff\n0x01\tMin bias current\n0x3F\tMax bias frequency'
vco_vtune_ctrl_help = 'VCO Vtune setting\nBits\n1:0\tVtune setting\n4\tVtune Set\n5\tVtune/ATC Low threshold mux func enable\n\nVtune setting\n00\t1.3 V\n01\t1.5 V\n10\t1.4 V\n11\t1.1 V'
vco_vtune_atc_lo_th_help = 'VCO Vtune setting for Vtune/ATC Low Threshold mux func'
vco_amux_ctrl_help = 'VCO Analog Mux Control\nBits\n3:0\tAmux Select\n4\tAmux Enable\n\nAmux select\n0\tALC Threshold\n1\tVCO Amplitude\n2\tATC Low Threshold\n3\tATC High Threshold\n4\tVCC VCO\n5\tVCC CHP\n6\tVCC Synth * 3/4\n7\tVCC \
TX BB * 3/4\n8\tVCC RX BB * 3/4'

vco_vtune_th_help = 'VCO Tune Vtune Threshold'
vco_atc_hi_th_help = 'VCO ATC High Threshold'
vco_atc_lo_th_help = 'VCO ATC Low Threshold'
vco_alc_hi_th_help = 'VCO ALC High Threshold'
vco_override_ctrl_help = 'VCO Override Control\nBits\n0\tExternal LO buffer in Enable override\n1\tExternal LO buffer out Enable override\n2\tPLL divider buffer out Enable override\n3\tX3 buffer out Enable override\n4\tVCO Enable \
override\n5\tVCO Comparator Enable override\n6\tVCO Vtune set override\n7\tVCO Digital tune override\n8\tVCO Ibias override'

vco_alc_del_help = 'VCO ALC Delay value'
vco_vtune_del_help = 'VCO Vtune Delay value'
vco_tune_loop_del_help = 'VCO Tune loop delay value\nBits\n17:0\tDelay value'
vco_atc_vtune_set_del_help = 'VCO ATC vtune set delay value\nBits\n17:0\tDelay value'
vco_atc_vtune_unset_del_help = 'VCO ATC vtune unset delay value\nBits\n17:0\tDelay value'
vco_tune_ctrl_help = 'VCO Automatic Tune Control\nStart bit should be toggled, which can be achieved by writing 1 to bit 0 using SPI/SPB Bit toggle order.\nBits\n0\tStart\n1\tReset\n2\tRetry\n4\tStart ALC SM\n5\tStart FD SM\n6\tStart Vtune SM'
vco_tune_status_help = 'VCO Automatic Tune Status. (Read only)\nBits\n0\tMain loop Done\n1\tMain loop Ok\n2\tATC Done\n3\tATC Ok\n4\tALC Done\n5\tALC Ok\n6\tFD Done\n7\tVtune Done'
vco_tune_det_status_help = 'VCO Automatic Tune Detector  Status. (Read only)\nBits\n0\tPLL LD\n1\tALC High Threshold\n2\tATC Low Threshold\n3\tATC High Threshold'
vco_tune_freq_cnt_help = 'VCO Tune Frequency Count. (Read only)\nBits\n11:0\tFrequency count value'
vco_tune_dig_tune_help = 'VCO Tune Digital tune value. (Read only)\nBits 6:0 value\n0x00\tMin frequency\n0x7F\tMax frequency'
vco_tune_ibias_help = 'VCO Tune Ibias value. (Read only)\nBits 5:0 value\n0x00\tOff\n0x01\tMin bias current\n0x3F\tMax bias frequency'
vco_tune_vtune_help = 'VCO Tune Vtune value (Read-only)'
vco_tune_fd_polarity_help = 'VCO Tune Frequency Detector polarity\nBits\n0\t0 = Negative polarity, 1 = Positive polarity'
rx_gain_ctrl_mode_help = 'RX Gain Control Mode\nGain Control Mode\n00\tExternal AGC control\n01\tInternal AGC control\n10\tRegister Index \
control\n11\tRegister Direct control\n\nBits\n1:0\tGain Control mode\n3\t1 = Leave selects in rx_gain_ctrl_sel untouched.\n\t0 = Set selects \
in rx_gain_ctrl_sel to same value as written.(Bit is auto-cleared)\n4\tStore AGC value in AWV Table\n5\tUse AGC value from AWV Table during Internal AGC Idle state'

rx_gain_ctrl_reg_index_help = 'RX Gain Control by Index'
rx_gain_ctrl_sel_help = 'RX Gain Control Select\nGain Control Mode\n00\tExternal AGC control\n01\tInternal AGC control\n10\tRegister Index control\n11\tRegister Direct \
control\nBits\n\n9:8\tGain Control mode for BF VGA gain\n7:6\tGain Control mode for RF VGA gain\n5:4\tGain Control mode for BB VGA1 gain\n3:2\tGain Control mode for BB VGA2 gain\n1:0\tGain Control mode for BB VGA3 gain'

rx_gain_ctrl_bfrf_help = 'RX BF VGA and RF VGA gain settings (Max gain 15dB typical)\nBits 3:0 value (RF Gain)\n0x0 = max gain – 15 dB\n...\n0xF = max gain\n\nBits 7:4 value(BF Gain)\n0x0 = max gain – 15 dB\n...\n0xF = max gain'
rx_gain_ctrl_bb1_help = 'RX BB VGA1 gain setting for Q- and I-channel\nBits\n3:0\tVGA1 I-channel\n7:4\tVGA1 Q-channel\nAllowed values per channel: 0xF, 0x7, 0x3, 0x1, 0x0,\nwhere \
0xF is the highest gain and then the gain drops by 6 db per step down to the setting 0x0.'

rx_gain_ctrl_bb2_help = 'RX BB VGA2 gain setting for Q- and I-channel\nBits\n3:0\tVGA2 I-channel\n7:4\tVGA2 Q-channel\nAllowed values per channel: 0xF, 0x7, 0x3, 0x1, 0x0,\nwhere \
0xF is the highest gain and then the gain drops by 6 db per step down to the setting 0x0'

rx_gain_ctrl_bb3_help = 'RX BB VGA3 gain setting for Q- and I-channel\nBits\n3:0\tVGA3 I-channel\n7:4\tVGA3 Q-channel\nRange 0 - 0xF : 0 - 6 dB'
rx_bb_q_dco_help = 'RX BB Q-channel DC Offset\nBits 6:0 value(Offset)\n0x7F:\tMax positive offset value\n0x40:\tNo offset compensation\n0x00:\tMax negative offset value\n\nBits 9:8 \
value (Offset shift)\n00:\tNo shift\n01:\tNegative shift (by 87% of offset value range)\n10:\tPositive shift (by 87% of offset value range)\n11:\tNot used\n\nBits 13:12 value (Multiplication \
factor on Offset value)\n00:\tx1\n01:\tx2\n10:\tx3\n11:\tx4'

rx_bb_i_dco_help = 'RX BB I-channel DC Offset\nBits 6:0 value(Offset)\n0x7F:\tMax positive offset value\n0x40:\tNo offset compensation\n0x00:\tMax negative offset value\n\nBits 9:8 \
value (Offset shift)\n00:\tNo shift\n01:\tNegative shift (by 87% of offset value range)\n10:\tPositive shift (by 87% of offset value range)\n11:\tNot used\n\nBits 13:12 value (Multiplication \
factor on Offset value)\n00:\tx1\n01:\tx2\n10:\tx3\n11:\tx4'

rx_dco_en_help = 'RX DCO Enable\nBits\n0:\tenable DC Offset compensation'
rx_bb_biastrim_help = 'Fine trim bias for BB VGA1, VGA2\n\nBits 2:0 value(VGA1)\n000\tNominal bias current\n001\t-4% bias current\n...\n111\t-28% bias current\n\nBits 5:3 value (VGA2)\n000\tNominal \
bias current\n001\t-4% bias current\n...\n111\t-28% bias current'

rx_bb_test_ctrl_help = 'RX BB Test Control\nBits\n1:0\tI/Q select\n3:2\tParameter select\n6:4\tSource select\n7:\tEnable BB_RX AMUX\n\nI/Q select\n00\tUnused\n01\tI-channel\n10\tQ-channel\n11\tUnused\n\nParameter \
select\n00\tPower Detector (For VGA3; voltage on output current node, for CM measurement)\n01\tPower Detector Threshold (For VGA3; voltage on output current node, for CM measurement)\n10\tDC-level P\n11\tDC-level N\n\nSource \
select\n000\tOut-of-band detector\n001\tInput buffer\n010\tVGA1\n011\tVGA2\n100\tVGA3\n101\tOutput buffer\n110\tUnused\n111\tUnused'

rx_drv_dco_help = 'RX DCO Drive control\n\nBit 0:\t\t1=Enabled LNAs   0=Disabled LNAs\nBits 12:8:\t\tDriver dco offset for BB_Q.\nBit 13:\t\t1=BB_Q Positive offset   0=BB_Q Negative offset\nBits 18:14:\tDriver dco offset \
for BB_I.\nBit 19:\t\t1=BB_I Positive offset   0=BB_I Negative offset'

agc_int_ctrl_help = 'Internal AGC Control (Toggle register)\nStart and Reset bits should be toggled, which can be achieved \nby writing 1 to corresponding bit using SPI/SPB Bit toggle order.\nThese are optional controls to \
the direct controls via GPIO:s\nBits 1:0\n0\tStart\n1\tReset'

agc_int_en_ctrl_help = 'Internal AGC Enable\nBits 4:0\n0\tBFRF and BB gain adjust separation enable\n1\tStart delay timer enable\n2\tTimeout timer enable\n3\tAGC backoff enable\n4\tWait for detection trigger'
agc_int_backoff_help = 'Internal AGC Backoff setting\nBits 7:0\n7:0\tAGC Backoff (in dB)'
agc_int_start_del_help = 'Internal AGC Start Delay (7:0)'
agc_int_timeout_help = 'Internal AGC Timeout (7:0)'
agc_int_gain_change_del_help = 'Internal AGC Gain Change Duration (3:0)'
agc_int_pdet_en_help = 'Internal AGC Power Detector Enable\n\nBits 3:0\n3:2\tDetector Reset Control\n1\tOutband Power Detector Enable\n0\tBFRF, BB VGA1, VGA2 and VGA3 Power Detector Enable\n\nDetector Reset \
Control\n00\tDetector reset inactive\n01\tDetector controlled by AGC (1 cycle long)\n10\tDetector controlled by AGC (2 cycles long)\n11\tDetector reset active'

agc_int_pdet_filt_help = 'Internal AGC Power Detector Filter\nBits 12:0\n4:0\tPower Detector mask for I-channel\n12:8\tPower Detector mask for Q-channel'
agc_int_pdet_th_help = 'Internal AGC Power Detector Thresholds\nBits 39:0\n39:32\tOutband Power Detector Threshold\n31:24\tBFRF VGAs Power Detector Threshold\n39:16\tBB VGA1 Power Detector Threshold\n15:8\tBB \
VGA2 Power Detector Threshold\n7:0\tBB VGA3 Power Detector Threshold'

agc_int_bfrf_gain_lvl_help = 'Internal AGC BF and RF Gain Level settings\nBits 31:0\n3:0\tRF gain setting 0 dB\n7:4\tBF gain setting 0 dB\n11:8\tRF gain setting 6 dB\n15:12\tBF gain setting 6 dB\n19:16\tRF gain \
setting 12 dB\n23:20\tBF gain setting 12 dB\n27:24\tRF gain setting 18 dB\n31:28\tBF gain setting 18 dB'

agc_int_bb3_gain_lvl_help = 'AGC BB VGA3 Gain Level settings\nBits 23:0\n3:0\tBB VGA3 Gain setting 0 dB\n7:4\tBB VGA3 Gain setting 1 dB\n11:8\tBB VGA3 Gain setting 2 dB\n15:12\tBB VGA3 Gain setting \
3 dB\n19:16\tBB VGA3 Gain setting 4 dB\n23:20\tBB VGA3 Gain setting 5 dB'

agc_int_status_pdet_help = 'Internal AGC Detector Status (Read only)\nBits 12:0\n4:0\tI-channel detector status\n12:8\tQ-channel detector status'
agc_int_status_help = 'Internal AGC Status (Read only)\nBits 1:0\n0\tAGC Done\n1\tAGC Timeout'
agc_int_gain_help = 'Internal AGC Gain (Read only)'
agc_int_gain_setting_help = 'Internal AGC Gain Setting (Read only)\nBits 31:0\n3:0\tBB VGA3 Gain setting I-channel\n7:4\tBB VGA3 Gain setting Q-channel\n11:8\tBB VGA2 Gain setting I-channel\n15:12\tBB VGA2 \
Gain setting Q-channel\n19:16\tBB VGA1 Gain setting I-channel\n23:20\tBB VGA1 Gain setting Q-channel\n27:24\tRF Gain setting\n31:28\tBF Gain setting'

agc_ext_ctrl_help = 'External AGC Control\nBits 2:0\n2\tEnable DDR mode (1=DDR, 0=SDR)\n1\tSDR sample edge (1= rising, 0=falling)\n0\tAlign Index update to last falling edge'
trx_ctrl_help = 'TX/RX enable control (1=enable)\nTX/RX-switching together with TX ALC and/or TX/RX Soft switch functions should only\nbe performed when GPIO Control is enabled, or else proper functionality \
of TX ALC and/or\nTX/RX Soft switch cannot be guaranted.\n\nBits 3:0\n0\tRX Enable\n1\tTX Enable\n3\tGPIO Control Enable\n4\tRX Soft switch enable\n5\tTX Soft switch enable'

trx_soft_ctrl_help = 'TX/RX Soft switch enable control\nBits 5:4 in register trx_ctrl are the same as bits 1:0 in this register.\nBits\n0\tRX Soft switch enable\n1\tTX Soft switch enable'
trx_soft_delay_help = 'TX/RX Soft switch delay\nBits\n2:0\tDelay for each enable/disable state'
trx_soft_max_state_help = 'TX/RX Soft switch maximum/last state\nBits\n2:0\tMaximum/Last state for soft switch'
trx_tx_on_help = 'TX bias on control when TX mode is active\n\nBits\n20\tEnable TX PA bias loop\n19\tEnable TX BF VGAs\n18\tEnable TX Q Baseband\n17\tEnable TX I Baseband\n16\tEnable TX mixer- and LO-buffer, \
RF VGA and common PA\n15:0\tEnable TX BF ports 15-0'

trx_tx_off_help = 'TX bias on control when TX mode is inactive\n\nBits\n20\tEnable TX PA bias loop\n19\tEnable TX BF VGAs\n18\tEnable TX Q Baseband\n17\tEnable TX I Baseband\n16\tEnable TX mixer- and LO-buffer, \
RF VGA and common PA\n15:0\tEnable TX BF ports 15-0'

trx_rx_on_help = 'RX bias on control when RX mode is active\n\nBits\n20\tEnable RX Q Baseband Output buffer\n19\tEnable RX Q Baseband Input Buffer, VGA1-3\n18\tEnable RX I Baseband Output buffer\n17\tEnable RX I \
Baseband Input Buffer, VGA1-3\n16\tEnable RX mixer- and LO-buffer, RF VGA\n15:0\tEnable RX BF ports 15-0'

trx_rx_off_help = 'RX bias on control when RX mode is inactive\n\nBits\n20\tEnable RX Q Baseband Output buffer\n19\tEnable RX Q Baseband Input Buffer, VGA1-3\n18\tEnable RX I Baseband Output buffer\n17\tEnable RX I \
Baseband Input Buffer, VGA1-3\n16\tEnable RX mixer- and LO-buffer, RF VGA\n15:0\tEnable RX BF ports 15-0'

trx_soft_tx_on_enables_help = 'TX/RX Soft switch TX mode transition enables\n\nTX Enables (bits 19:16 in register trx_tx_on)\n4\tEnable TX PA bias loop\n3\tEnable TX BF VGAs\n2\tEnable TX Q Baseband\n1\tEnable TX I \
Baseband\n0\tEnable TX mixer- and LO-buffer, RF VGA and common PA\n\nBits\n60:56\tTX enables for state 0\n52:48\tTX enables for state 1\n44:40\tTX enables for state 2\n36:32\tTX enables for state 3\n28:24\tTX enables \
for state 4\n20:16\tTX enables for state 5\n12:8\tTX enables for state 6\n4:0\tTX enables for state 7'

trx_soft_rx_on_enables_help = 'TX/RX Soft switch RX mode transition enables\n\nRX Enables (bits 17:16 in register trx_rx_on)\n4\tEnable RX Q Baseband Output buffer\n3\tEnable RX Q Baseband Input Buffer, VGA1-3\n2\tEnable \
RX I Baseband Output buffer\n1\tEnable RX I Baseband Input Buffer, VGA1-3\n0\tEnable RX mixer- and LO-buffer, RF VGA\n\nBits\n60:56\tRX enables for state 0\n52:48\tRX enables for state 1\n44:40\tRX enables for \
state 2\n36:32\tRX enables for state 3\n28:24\tRX enables for state 4\n20:16\tRX enables for state 5\n12:8\tRX enables for state 6\n4:0\tRX enables for state 7'

trx_soft_bf_on_grp_sel_help = 'TX/RX Soft switch BF element enable group select\n\nGroup select\tBF element enables\n0000\t\t0x0000\n0001\t\t0x0180\n0010\t\t0x03C0\n0011\t\t0x07E0\n0100\t\t0x0FF0\n0101\t\t0x1FF8\n0110\t\t0x3FFC\n0111\t\t0x7FFE\n\
1000\t\t0xFFFF\n1001\t\t0x8001\n1010\t\t0xC003\n1011\t\t0xE007\n1100\t\t0xF00F\n1101\t\t0xF81F\n1110\t\t0xFC3F\n1111\t\t0xFE7F\n\nBits\n31:28\tGroup select for state 0\n27:24\tGroup select for state 1\n23:20\tGroup select for state 2\n19:16\tGroup \
select for state 3\n15:12\tGroup select for state 4\n11:8\tGroup select for state 5\n7:4\tGroup select for state 6\n3:0\tGroup select for state 7'
